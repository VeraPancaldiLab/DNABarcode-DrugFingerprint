[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inferring the MoA of drugs based on barcode fingerprints.",
    "section": "",
    "text": "Welcome\nThis is the online Quarto book project for reproducing: Inferring the mechanism of action of new drugs through the analysis of the predetermined heterogeneous response to treatment of different subpopulations of cancer cells poster, presented at NetBioMed 2022 conference.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#introduction-cell-lines-dna-barcoding",
    "href": "index.html#introduction-cell-lines-dna-barcoding",
    "title": "Inferring the MoA of drugs based on barcode fingerprints.",
    "section": "Introduction: Cell lines DNA Barcoding",
    "text": "Introduction: Cell lines DNA Barcoding\n\nDNA barcoding is also used for inferring the species abundancies in environement samples, just replace the notion of species by cell lines. Similar statistical issues, with zero-inflated distributions.\nSteps:\n\nTransfection by virus.\nClonal amplification, unique tagging per cell using MOI.\nClone sizes are assumed to be proportional to the barcode abundances due to this 1-1 mapping of a barcode and a single cell.\n\nPros DNA barcoding:\n\nBetter capture of cell population sizes\nBetter tracking of tagged clones.\n\nCons DNA barcoding:\n\nLack of systematic reviews and benchmarks.\nMostly rely on bulk RNASeq analytical tools, not accounting for drop-outs. In particular, the assumptions that variance across tags is homogeneous, and abundancies follow a negative binomial distribution are quite controversial.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "data-management.html",
    "href": "data-management.html",
    "title": "\n1  Data management: metadata correction and cleansing\n",
    "section": "",
    "text": "1.1 Reproducibility\nI list below the R packages required to reproduce the analyses.\nCode## data wrangling\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(readr)\nlibrary(readxl)\nlibrary(purrr)\n\n## reporting\nlibrary(flextable)\n\n## plotting\nlibrary(ggplot2)\nlibrary(ComplexHeatmap)\nlibrary(cowplot)\nlibrary(grid)\nlibrary(RColorBrewer)\nlibrary(igraph)\n\n## auxiliary functions\nsource(\"R/utils.R\")\ntoday_date &lt;- \"2025-04-28\"\n## today_date &lt;- format(Sys.Date(), \"%Y-%m-%d\")\n\n## set the seed, for fixing generation of ComplexHeatmaps (dendogram clustering)\nset.seed(20)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data management: metadata correction and cleansing</span>"
    ]
  },
  {
    "objectID": "data-management.html#reproducibility",
    "href": "data-management.html#reproducibility",
    "title": "\n1  Data management: metadata correction and cleansing\n",
    "section": "",
    "text": "Original Google Drive repository.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data management: metadata correction and cleansing</span>"
    ]
  },
  {
    "objectID": "data-management.html#sec-select-exp",
    "href": "data-management.html#sec-select-exp",
    "title": "\n1  Data management: metadata correction and cleansing\n",
    "section": "\n1.2 Barcode counts cleaning",
    "text": "1.2 Barcode counts cleaning\nWe early discarded exp130921_in vivo.csv from the experiences\n\n\n\n\n\n\n\n\n\n\n\n\n\nListing 1.1: Update labelling of latest experience.\n\nexp271221 &lt;- readr::read_csv(\"data/barcode-counts/exp271221.csv\") \nexp271221_whole &lt;- readr::read_csv2(\"old-data-backup/data-raw/barcode-counts/exp211221cor.csv\") |&gt; \n  rename(barcode_id = 1)\nselected_dataset &lt;- compare_dataframes(exp271221, exp271221_whole)\n\nfile.rename(\"data/barcode-counts/exp211221.csv\", \"data/barcode-counts/exp271221.csv\") \n\n\n\n\nIn Listing 1.1, we rename expression file exp211221.csv into exp271221.csv, relying on date annotations.\nWhile the dose-response experience exp200921_dose response osim exhibits distinct biological objective, it turned out that the 4 control biological replicates are shared with classical compound response comparison exp200921.csv. However, the number of sequenced barcode IDs differ in both experiences!! In addition, note that exp200921.csv has been tagged as discarded, except for the Controls!!\nCode snippets in Listing 1.2 and Listing 1.3 aim at replacing unprecise labelling of barcode IDs (no concentration, no time duration, …) in the 2022 batch experiences.\n\n\n\nListing 1.2: Update labelling of latest experience.\n\n## extract old colnames\nexp281022_expression &lt;- readr::read_csv(\"data/barcode-counts/exp281022.csv\") \n## cat(colnames(exp281022_expression), file = \"281022_old_labels.txt\", sep = \"\\n\")\n\n## extract mapping old_names with new_names\nmapping_old_new_281022 &lt;- readxl::read_excel(\"data/Table of compounds_whole_2025-04-28.xlsx\", \n                                             sheet = \"Sample Mapping 281022\")\n\nlabels_old_new_281022 &lt;- setNames(object = mapping_old_new_281022$OLD_replicate_label, \n                                  nm = mapping_old_new_281022$NEW_replicate_label)\n\n## apply change labelling\nexp281022_expression &lt;- exp281022_expression |&gt; \n  dplyr::rename(dplyr::all_of(labels_old_new_281022))\n\nreadr::write_csv(exp281022_expression, \"data/barcode-counts/exp281022.csv\")\n\n\n\n\n\n\n\nListing 1.3: Update time course experiences.\n\nexp281022_expression_timecourse &lt;- readr::read_csv(\"data/barcode-counts/exp281022_time course.csv\") \n## cat(colnames(exp281022_expression_timecourse), file = \"281022_timecourse_old_labels.txt\", sep = \"\\n\")\n\n## update colnames ----\n\nmapping_old_new_time_course &lt;- read_excel(\"data/Table of compounds_whole_2025-04-28.xlsx\", \n                                     sheet = \"Sample Mapping Time Course\")\n\nlabels_old_new_time_course &lt;- setNames(object = mapping_old_new_time_course$OLD_replicate_label, \n                                       nm = mapping_old_new_time_course$NEW_replicate_label)\n\n## apply change labelling\nexp281022_expression_timecourse &lt;- exp281022_expression_timecourse |&gt; \n  dplyr::rename(dplyr::all_of(labels_old_new_time_course))\n\nreadr::write_csv(exp281022_expression_timecourse,\n                 \"data/barcode-counts/exp281022_time course.csv\")\n\n## To evaluate whether controls are different between experiment 281022 and 281022 Time Course\ncontrols_exp281022 &lt;- exp281022_expression |&gt; \n  select(key_barcode, dplyr::matches(\"^ctl\")) |&gt; \n  dplyr::inner_join(exp281022_expression_timecourse |&gt; \n                      select(key_barcode, dplyr::matches(\"^Ctrl\")),\n                    by=\"key_barcode\")\ncor(controls_exp281022$ctl2, controls_exp281022$Ctrl2) ## they strongly correlate with each other, but not a perfect match -&gt; controls are indeed distinct\n\n\n\n\n\n\n\n\n\n1.2.1 TODO: barcode counts inconsistencies\nThings to consider:\n\nFormat used is French csv, instead of international CSV. CSV means for ‘comma-separated value’, maybe consider switching Excel settings.\nI rename the first colname of each expression file as barcode_id, storing unequivocal tag.\nSome barcode counts exhibit final line index, for which reason?\n\n1.2.2 Overview of barcode counts\nWe report in Table 1.1 a summary of the barcode counts (File location, batch_id, and dimensions of the counts matrix) considered for the generation of the Heatmaps, and the construction of a drug-drug network.\nCode## 1) summarise kept batches ----\nbarcode_files &lt;- list.files(\"./data/barcode-counts/\",\n                            pattern = \"exp.*\\\\.csv\",\n                            full.names = TRUE)\n\nkept_barcode_summaries &lt;- purrr::map(barcode_files, function(filename) {\n  barcode_counts &lt;- readr::read_csv(filename, show_col_types = FALSE)\n  experience_name &lt;- filename |&gt; basename() |&gt; tools::file_path_sans_ext()\n  experience_summary &lt;- tibble::tibble(`Experience Name`= experience_name,\n                                       Features= paste0(\"Barcode matrix contains: \",\n                                                        nrow(barcode_counts),\n                                                        \" unique barcode IDs, and \",\n                                                        ncol(barcode_counts)-1, \" replicates.\"))\n  return(experience_summary)\n}) |&gt;\n  purrr::list_rbind()\nflextable::flextable(kept_barcode_summaries) |&gt; \n  bold(part=\"header\")\n\n## 2) summarise discarded batches ----\ndiscarded_files &lt;- list.files(\"./data/barcode-counts/temp discarded/\",\n                            pattern = \"exp.*\\\\.csv\",\n                            full.names = TRUE)\n\n## change format + barcode name\nbarcode_discarded_summaries &lt;- purrr::map(discarded_files, function(filename) {\n  barcode_counts &lt;- readr::read_csv(filename, show_col_types = FALSE)\n  experience_name &lt;- filename |&gt; basename() |&gt; tools::file_path_sans_ext()\n  experience_summary &lt;- tibble::tibble(`Experience Name`= experience_name,\n                                       Features= paste0(\"Barcode matrix contains: \",\n                                                        nrow(barcode_counts),\n                                                        \" unique barcode IDs, and \",\n                                                        ncol(barcode_counts)-1, \" replicates.\"))\n  return(experience_summary)\n}) |&gt;\n  purrr::list_rbind()\n\nflextable::flextable(barcode_discarded_summaries) |&gt; \n  bold(part=\"header\")\n\n\n\n\n\n\n\n\n\n\n\nExperience Name\nFeatures\n\n\n\nexp010821\nBarcode matrix contains: 869714 unique barcode IDs, and 16 replicates.\n\n\nexp040821\nBarcode matrix contains: 869714 unique barcode IDs, and 16 replicates.\n\n\nexp070222\nBarcode matrix contains: 93132 unique barcode IDs, and 68 replicates.\n\n\nexp130921\nBarcode matrix contains: 627539 unique barcode IDs, and 24 replicates.\n\n\nexp151121\nBarcode matrix contains: 844434 unique barcode IDs, and 60 replicates.\n\n\nexp181021\nBarcode matrix contains: 813579 unique barcode IDs, and 59 replicates.\n\n\nexp200921\nBarcode matrix contains: 627539 unique barcode IDs, and 40 replicates.\n\n\nexp200921_dose response osim\nBarcode matrix contains: 1067031 unique barcode IDs, and 20 replicates.\n\n\nexp220322\nBarcode matrix contains: 93132 unique barcode IDs, and 66 replicates.\n\n\nexp271221\nBarcode matrix contains: 844434 unique barcode IDs, and 80 replicates.\n\n\nexp281022\nBarcode matrix contains: 315642 unique barcode IDs, and 22 replicates.\n\n\nexp281022_time course\nBarcode matrix contains: 398004 unique barcode IDs, and 51 replicates.\n\n\nexp300821\nBarcode matrix contains: 413335 unique barcode IDs, and 28 replicates.\n\n\n\n\n\n\n\n(a) Kept Batches\n\n\n\n\n\n\n\n\n\n\n\nExperience Name\nFeatures\n\n\n\nexp130921_in vivo\nBarcode matrix contains: 813579 unique barcode IDs, and 16 replicates.\n\n\nexp200921_dose response osim\nBarcode matrix contains: 813579 unique barcode IDs, and 20 replicates.\n\n\n\n\n\n\n\n(b) Removed batches\n\n\n\n\n\n\nTable 1.1: Overview of the Barcoding Batches.\n\n\nFrom Table 1.1, 13 barcode experiences are included in the analysis, whereas 2 batches/experiences are filtered out.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data management: metadata correction and cleansing</span>"
    ]
  },
  {
    "objectID": "data-management.html#sec-metadata-phenotypes",
    "href": "data-management.html#sec-metadata-phenotypes",
    "title": "\n1  Data management: metadata correction and cleansing\n",
    "section": "\n1.3 Phenotype metadata cleaning",
    "text": "1.3 Phenotype metadata cleaning\n\nGeneral question: what’s the difference between Run Date and Experiment Date?\n\nMost of the R instructions reported in this section aim at rendering the Table of compounds file compliant with the tidy format, see Tip 1.1. These data-wrangling operations are split in 4 steps:\n\nIn Listing 1.4, we homogenise Concentrations, Date and Duration to ISO standards, while dealing with erroneous missing values generated by fused Excel cells. Besides, we removed special, non-ascii characters that could not be processed by visualisation plots, such as \\(NF-\\kappa B\\).\nIn Listing 1.5, we retrieve from each individual barcode counts profile, the individual replicates ID identifying unequivocally each replicate. We set apart replicates that could be mapped back to original Table of compounds file.\nIn Listing 1.6, we merge together in a comprehensive phenotype table the short Samples_ID (short term referring to drugs listed in Compound column), the full Compound (complete name of drugs) and map each of them to its complete list of replicates (from 2 to 8). We save the output in data-derived.\nFinally, in Listing 1.7 and Listing 1.8, we perform several posterior data integrity checks to verify if i) we were able to map each individual replicate ID to its original ID in Table of compounds, and ii) if the number of replicates reported in Table of compounds was consistent with the number of barcode profiles.\n\n\n\n\nListing 1.4: Coerce original Excel file reporting experimental design to tidy format.\n\npheno_colnames &lt;- c(Pathway = \"Pathways\", MoA = \"...2\", \n                    Compound = \"Samples\", Replicates = \"Replicates\",\n                    Concentrations = \"Concentrations\", Date = \"Experiment date\",\n                    `Run date` = \"Run date\", Duration=\"Duration\", \n                    Kept=\"Kept\", Comments = \"Comments\")\n\n## prune irrelevant colnames ----\n## data/Table of compounds_stringent_2025-04-18.xlsx\npheno_data &lt;- readxl::read_xlsx(\"data/Table of compounds_whole_2025-04-28.xlsx\",\n                                sheet = \"Experimental Design\",\n                                col_types = c(rep(\"text\", 3), \"numeric\", \n                                              rep(\"text\", 4), \"logical\", \"text\")) |&gt;\n  dplyr::rename(dplyr::all_of(pheno_colnames)) |&gt;\n  tidyr::fill(Pathway, MoA, .direction = \"down\")\n\npheno_data_discarded &lt;- pheno_data |&gt; \n  dplyr::filter(!Kept)\n\n## Add batches and correct for fused Excel cells ----\n\npheno_data &lt;- pheno_data |&gt; \n  ## extract last 6 numbers\n  dplyr::mutate(Compound = if_else(grepl(\"Control\", MoA, ignore.case = TRUE),\n                                  MoA, Compound),\n                `Run date` = stringr::str_sub(`Run date`, -6, -1),\n                Batch_ID= paste0(\"exp\", Date)) |&gt; \n  tidyr::fill(Compound, .direction = \"down\") |&gt;\n  ## remove unwanted replicates\n  dplyr::filter(Kept) |&gt; \n  dplyr::mutate(Batch_ID = dplyr::if_else(Comments %in% c(\"Dose Response\"), \n                                          \"exp200921_dose response osim\", Batch_ID)) |&gt; \n  dplyr::mutate(Batch_ID = dplyr::if_else(Comments %in% c(\"Time Course\"), \n                                          \"exp281022_time course\", Batch_ID), \n                Pathway = if_else(is.na(Pathway), MoA, enc_to_ascii(Pathway))) |&gt; \n  dplyr::select(- Comments, -Kept) |&gt; \n  dplyr::distinct(.keep_all = TRUE) ## remove duplicates\n\n## format concentrations, creating both 'Concentrations_ID' and 'Concentrations' in Moles ----\npheno_data &lt;- pheno_data |&gt; \n  dplyr::mutate(Concentrations=if_else(Compound==\"Control\", \"000 uM\", Concentrations)) |&gt; \n  dplyr::mutate(Concentrations=if_else(Compound==\"Osimertinb+sorafenib\", \"015 uM\", Concentrations)) |&gt;\n  tidyr::separate_wider_delim(Concentrations, delim = \" \", names = c(\"Concentrations Value\", \"Unit\"), cols_remove = FALSE) |&gt; \n  dplyr::rename(OLD_Concentrations=Concentrations) |&gt; \n  dplyr::mutate(Unit = case_when(\n    Unit %in% c(\"uM\", \"µM\", \"µg/ml\") ~ \"u\",\n    Unit == \"nM\" ~ \"n\", \n    Unit %in% c(\"mg/kg\", \"mM\") ~ \"m\", \n  )) |&gt; \n  dplyr::mutate(Concentrations=parse_number(`Concentrations Value`, trim_ws = TRUE, \n                                            locale = locale(decimal_mark = \",\", grouping_mark = \".\"))) |&gt; \n   dplyr::mutate(Concentrations = case_when(\n    Unit == \"u\" ~ Concentrations *10^-6,\n    Unit == \"n\" ~ Concentrations *10^-9, \n    Unit == \"m\" ~ Concentrations *10^-3)) |&gt; \n  dplyr::mutate(`Concentrations Value`=parse_number(`Concentrations Value`, trim_ws = TRUE, \n                                            locale = locale(decimal_mark = \",\", grouping_mark = \".\")) |&gt; \n                  format_concentrations()) |&gt; \n  tidyr::unite(col =\"Concentrations_ID\", `Concentrations Value`, Unit, sep = \"\")\n\n## format Durations, creating both 'Duration_ID' and 'Duration' as an integer value in Days ----\npheno_data &lt;- pheno_data |&gt; \n  ## extract last 6 numbers, as the only ones used for identification of samples downstream\n  dplyr::mutate(Duration_ID = Duration,\n                Duration = parse_number(Duration, trim_ws = TRUE, \n                                        locale = locale(decimal_mark = \".\")), \n                Duration = dplyr::if_else(grepl(\"m$\",  Duration_ID),\n                                          Duration*30, Duration)) \n  \n\n\n\n\n\n\n\n\n\n\nMetadata inconsistencies and Conversion to UIC Units\n\n\n\n\n\n\n\nIn Run date, when there was a range instead of a fixed Date, I kept only the end of the interval, as used for labelling colnames in barcode counts.\nHomogenise units for the Concentrations colname: convert everything to moles.\nHomogenise units for Date and Run date, using international ISO 8601 format: YYYY-MM-DD\n\n\n\n\nIn Listing 1.5 and Listing 1.6, we identify which raw barcode counts matrices avalaible in folder barcode-counts are not reported in the global experimental dataset, and reciprocally. Finally, we only keep experiences that are both reported in Table of compounds and present in barcode-counts folder..\n\n\n\nListing 1.5: Identify shared experience IDs between experimental design table (Table of compounds), and barcode-count counts profiles.\n\n## keep only relevant files \nbarcodes_filenames &lt;- list.files(\"./data/barcode-counts/\",\n                                pattern = \"^exp.*\\\\.csv$\")\n\nbarcodes_IDs &lt;- readxl::read_xlsx(\"data/Table of compounds_whole_2025-04-28.xlsx\",\n                                       sheet=\"Batch Mapping\") |&gt; \n  select(Filename, Batch_ID) |&gt; \n  filter(!Batch_ID %in% c(\"exp130921_in vivo\")) |&gt; \n  mutate(Filename =paste0(Filename, \".csv\"), \n         Date = stringr::str_extract(Batch_ID, \"(?&lt;=^exp)[[:digit:]]{6}\"))\n\n\n\n\n\n\n\n\n\n\nTo generate the final phenotype dataset, we only keep experiences that were reported both in Table of Compound and folder barcode-counts in Listing 1.6. Please ensure that Drugs Mapping sheet in Table of compounds is correct.\n\n\n\nListing 1.6: Map each compound to its full list of replicates. Generate a Batch_ID to unequivocally ientify each run of experiences, and convert all run Dates to their international format.\n\n## step 1) keep only shared Batch_ID experiences ----\nbarcodes_IDs &lt;- barcodes_IDs |&gt;\n  dplyr::semi_join(pheno_data, by=\"Batch_ID\")\n## exp201021 is discarded, that's normal, we just want to keep the controls!!\npheno_data &lt;- pheno_data |&gt;\n  dplyr::semi_join(barcodes_IDs, by=\"Batch_ID\")\n\n## step 2) extract individual replicate IDs directly from sample experiences ----\n## Filename &lt;- \"exp281022.csv\"; Batch_ID &lt;- \"exp281022\"; Date &lt;- \"281022\"\nID_mapping &lt;- purrr::pmap(barcodes_IDs, function(Filename, Batch_ID, Date) {\n  ## build path\n  counts_path &lt;- file.path(\"data\",\"barcode-counts\", \n                               paste0(Filename))\n  \n  ## extract replicate names (reading the header)\n  replicates_ID &lt;- strsplit(readLines(counts_path, n = 1), split = \",\")[[1]] |&gt;\n    str_subset(\"\\\\S\") |&gt; ## remove empty strings and 'key'\n    str_subset(\"barcode_id\", negate = TRUE)\n\n  ## ID: combination of letters, numbers and -, followed by '[1-4]_', starting the sample's name\n  dataset_ID &lt;- tibble::tibble(Batch_ID = Batch_ID, \n                               Date = stringr::str_extract(replicates_ID,\n                                                           \"(?&lt;=_exp)[[:alnum:]]{6}\"),\n                               Replicates_ID = replicates_ID,\n                               `Run date` = stringr::str_extract(replicates_ID,\n                                                                 \"(?&lt;=_run)[[:alnum:]]{6}(?=_)\"),\n                               Concentrations_ID = stringr::str_extract(replicates_ID, \n                                                                        \"(?&lt;=[1-8]_)[[:digit:]]{3}[gmnux]{1}(?=_exp)\")) |&gt; \n    ## account for second notation syntax for concentrations\n    dplyr::mutate(Concentrations_ID = if_else(is.na(Concentrations_ID), \n                                              stringr::str_extract(replicates_ID,\n                                                                   \"(?&lt;=[1-8]_)[0-9]{1}\\\\.[0-9]{2}[gmnux]{1}(?=_exp)\"),\n                                              Concentrations_ID))\n  \n  ## Deal with two time notations\n  if (grepl(\"Time\",Batch_ID, ignore.case = TRUE)) {\n    dataset_ID &lt;- dataset_ID |&gt; \n      dplyr::mutate (Samples_ID = stringr::str_extract(replicates_ID,\n                                                       \"(?&lt;=_)[[[:alnum:]]\\\\-]+(?=[1-8]_)\"), \n                     Duration_ID=stringr::str_extract(replicates_ID,\n                                                       \"^[[[:alnum:]]\\\\.]{1,3}[dm](?=_)\"))\n  }\n  else {\n      dataset_ID &lt;- dataset_ID |&gt; \n      dplyr::mutate (Samples_ID = stringr::str_extract(replicates_ID,\n                                                       \"^[[[:alnum:]]\\\\-]+(?=[1-8]{1}_)\"), \n                     Duration_ID=\"9d\")\n  }\n                                 \n  return(dataset_ID)\n}) |&gt;\n  purrr::list_rbind()\n\n## deal with specific p42 and p43\nID_mapping &lt;- ID_mapping |&gt; \n  dplyr::mutate(Samples_ID = if_else(grepl(\"^p42\", Replicates_ID), \"p42\", Samples_ID), \n                Samples_ID = if_else(grepl(\"^p43\", Replicates_ID), \"p43\", Samples_ID))\n\n## remove irrelavant samples\nID_mapping &lt;- ID_mapping |&gt; \n  dplyr::filter(!grepl(\"^p42|^p43|^CTRL\", Replicates_ID))\n\n\n## detect miscatech samples\n## ID_mapping_missing &lt;- ID_mapping |&gt;\n##   filter(if_any(everything(), is.na))\n\n## step 3) map short compound IDs with full compound names ----\nmapping_compounds &lt;- readxl::read_xlsx(\"data/Table of compounds_whole_2025-04-28.xlsx\",\n                                sheet = \"Drugs Mapping\")\nID_mapping &lt;- ID_mapping |&gt; \n  inner_join(mapping_compounds, by = \"Samples_ID\")\n## test &lt;- ID_mapping |&gt; anti_join(mapping_compounds, by = \"Samples_ID\")\n## test2 &lt;- mapping_compounds |&gt; anti_join(ID_mapping, by = \"Samples_ID\")\n\n\n\n\n\nFinally, in Listing 1.7, we map all replicates (one column in a given barcode count matrix) to its comprehensive metadata descripion (stored in Tables of compounds), using as primary and foreign keys the following 6 variables: Batch_ID, Compound, Duration_ID, Run date, Date, and Concentrations_ID.\n\n\n\nListing 1.7: Extract discarded replicates\n\nreplicates_discarded &lt;- dplyr::anti_join(ID_mapping, pheno_data,\n                                     by = c(\"Batch_ID\",  \"Compound\", \"Duration_ID\",\n                                            \"Run date\", \"Date\", \"Concentrations_ID\"))\n\npheno_data_unmapped &lt;- dplyr::anti_join(pheno_data,\n                                     ID_mapping,\n                                     by = c(\"Batch_ID\",  \"Compound\", \"Duration_ID\",\n                                            \"Run date\", \"Date\", \"Concentrations_ID\"))\n\npheno_data_unmapped |&gt; \n  arrange(Compound, Date, Concentrations_ID) |&gt; \n  flextable() |&gt; \n  bold(part = \"header\")\n\n\n\n\n\n\n\n\n\nPathway\nMoA\nCompound\nReplicates\nConcentrations_ID\nOLD_Concentrations\nDate\nRun date\nDuration\nBatch_ID\nConcentrations\nDuration_ID\n\n\n\n\n\nTable 1.2: Identify set of experiences reported in Table of compounds that could not be mapped against their corresponding Barcode counts replicates. We check this information with an anti_join between original phenotype and counts, returning samples from Table of Compound that could not have been mapped back.\n\n\n\nIn Table 1.3, we check discrepancies between the number of barcode replicates reported in Table of compounds with the number of replicates avalaible in barcode counts matrices. And it turned out that compound: XAV-939, Date: 220322, is reported with 4 replicates, while only 2 could be found in exp220322 barcode count matrix\n\n\n\nListing 1.8: Secound round of data wrangling quality controls on counts versus phenotype data, focusing on divergent number of replicates.\n\nreplicate_inconsistencies &lt;- pheno_data |&gt; \n  dplyr::inner_join(ID_mapping,\n                    by = c(\"Batch_ID\", \"Date\", \n                           \"Compound\", \"Run date\",\n                           \"Concentrations_ID\", \"Duration_ID\")) |&gt;\n  group_by(Batch_ID, Compound, Date, Replicates, Concentrations_ID,Duration_ID) |&gt;\n  summarise(n=n()) |&gt;\n  filter(n!=Replicates)\n\nflextable(replicate_inconsistencies) |&gt;\n  autofit() |&gt;\n  bold(part = \"header\")\n\n\n\n\n\n\n\n\n\n\nBatch_ID\nCompound\nDate\nReplicates\nConcentrations_ID\nDuration_ID\nn\n\n\nexp220322\nXAV-939\n220322\n4\n080u\n9d\n2\n\n\n\n\n\n\nTable 1.3: Secound round of data wrangling quality controls on counts versus phenotype data, focusing on divergent number of replicates.\n\n\n\n\n1.3.1 Save phenotype Metadata\nBy applying all the formatting analyses reported in Section 1.3, we generate in Table 1.4 a global metadata phenotypic table, adhering to tidy principles Tip 1.1.\n\n\n\n\n\n\nTip 1.1: Tidy Data Format (Key Principles)\n\n\n\n\n\n\n\nEach variable has its own column.\n\nEach observation has its own row – Every row corresponds to one observation.\n\nEach value has its own cell – Each cell contains a single, unique value.\n\nThis format streamlines data wrangling, and generally speaking, data analysis and visualisation. In other words, prefer simpler CSV formats for the experimental design, and avoid cell fusion in Excel documents. Finally, for the formatted tabular representation in documentations, I use flextable.\n\n\n\n\n\n\nListing 1.9: Save the final metadata annotations for barcodes, using Today’s date for historical versioning.\n\n## step 4) Use international date formats ----\npheno_data_formatted &lt;- pheno_data |&gt; \n  dplyr::inner_join(ID_mapping,\n                    by = c(\"Batch_ID\", \"Date\", \n                           \"Compound\", \"Run date\",\n                           \"Concentrations_ID\", \"Duration_ID\")) |&gt; \n  dplyr::select(Batch_ID, Pathway, MoA,\n                Compound, Samples_ID, \n                Replicates, Replicates_ID,\n                Concentrations, Concentrations_ID, \n                Date, `Run date`, Duration, Duration_ID) |&gt; \n  ## convert to ISO 1860 Date format\n  mutate(Date = lubridate::dmy(Date) |&gt; format(),\n         `Run date`= lubridate::dmy(`Run date`), \n  ## artifically de-duplicate controls for exp, simplify the analytical workflow \n  Replicates_ID = dplyr::if_else(Batch_ID %in% c(\"exp200921_dose response osim\") &\n                                   Compound==\"Control\",\n                                 gsub(\"exp200921_\", \"exp200921_dose_response_\", Replicates_ID),\n                                 Replicates_ID))\n\n## 2) QC: guarantee uniqueness of the replicates\npheno_data_deduplicated &lt;- pheno_data_formatted |&gt; \n  dplyr::distinct(Replicates_ID, .keep_all = TRUE)\nall.equal(pheno_data_deduplicated, pheno_data_formatted)\n##  [1] TRUE\n\n## 3) save as .xlsx file discarded and preserved replicates\n\nbarcode_counts_summaries &lt;- list(\"kept counts\" = kept_barcode_summaries,\n                                 \"kept compounds\" = pheno_data,\n                                 \"kept replicates\" = pheno_data_formatted |&gt; \n                                   select(Compound, Replicates_ID),\n                                 \"discarded counts\" = barcode_discarded_summaries, \n                                 \"discarded compounds\"=pheno_data_discarded, \n                                 \"discarded replicates\" = replicates_discarded)\n\nopenxlsx::write.xlsx(x = barcode_counts_summaries,\n                     file = paste0(\"./data/logs/barcode_metadata_overview_\",\n                                   today_date,\".xlsx\"),\n                     overwrite = TRUE, asTable = TRUE)\n\n\n## 4) save the tidy phenotype metatada table ----\nreadr::write_csv(pheno_data_formatted,\n                 file = paste0(\"data/pheno_data_metadata_\", today_date,\".csv\"))\n\nflextable::flextable(head(pheno_data_formatted)) |&gt; \n  autofit() |&gt; \n  bold(part=\"header\")\n\n\n\n\n\n\n\n\n\n\nBatch_ID\nPathway\nMoA\nCompound\nSamples_ID\nReplicates\nReplicates_ID\nConcentrations\nConcentrations_ID\nDate\nRun date\nDuration\nDuration_ID\n\n\n\nexp010821\nControl\nControl\nControl\nContro\n4\nContro1_000u_exp010821_run180821_03\n0\n000u\n2021-08-01\n2021-08-18\n9\n9d\n\n\nexp010821\nControl\nControl\nControl\nContro\n4\nContro2_000u_exp010821_run180821_04\n0\n000u\n2021-08-01\n2021-08-18\n9\n9d\n\n\nexp010821\nControl\nControl\nControl\nContro\n4\nContro3_000u_exp010821_run180821_05\n0\n000u\n2021-08-01\n2021-08-18\n9\n9d\n\n\nexp010821\nControl\nControl\nControl\nContro\n4\nContro4_000u_exp010821_run180821_06\n0\n000u\n2021-08-01\n2021-08-18\n9\n9d\n\n\nexp040821\nControl\nControl\nControl\nContro\n4\nContro1_000u_exp040821_run180821_25\n0\n000u\n2021-08-04\n2021-08-18\n9\n9d\n\n\nexp040821\nControl\nControl\nControl\nContro\n4\nContro2_000u_exp040821_run180821_26\n0\n000u\n2021-08-04\n2021-08-18\n9\n9d\n\n\n\n\n\n\n\nTable 1.4\n\n\n\nConclusion: on a total of 544, 532 replicates are kept, and 12 replicates were removed.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data management: metadata correction and cleansing</span>"
    ]
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "\n2  Methods: normalise, identify DRBs and save as SummarizedExperiment objects\n",
    "section": "",
    "text": "2.1 Reproducibility\nI list below the R packages required to reproduce the analyses.\nCode## data wrangling\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(readr)\nlibrary(readxl)\nlibrary(openxlsx)\nlibrary(purrr)\n\n## reporting\nlibrary(flextable)\n\n# automated package linting\nlibrary(xml2)\nlibrary(downlit)\n\n## auxiliary functions\nsource(\"R/utils.R\")\ntoday_date &lt;- \"2025-04-28\"\n## today_date &lt;- format(Sys.Date(), \"%Y-%m-%d\")\n\n## set the seed, for fixing generation of ComplexHeatmaps (dendogram clustering)\nset.seed(20)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Methods: normalise, identify DRBs and save as `SummarizedExperiment` objects</span>"
    ]
  },
  {
    "objectID": "methods.html#sec-batch-processing",
    "href": "methods.html#sec-batch-processing",
    "title": "\n2  Methods: normalise, identify DRBs and save as SummarizedExperiment objects\n",
    "section": "\n2.2 Preprocessing barcode counts",
    "text": "2.2 Preprocessing barcode counts\nCode colour: Luca’s protocol, and Bastien’s comments and perspectives\n\n2.2.1 Background Noise Removal and SummarizedExperiment stantardised storage\nEliminate barcodes for which the combined counts of the 4 controls per barcode are below a given threshold, here 5.\n\n\n\nListing 2.1: Remove background noise.\n\nbarcode_files &lt;- list.files(\"./data/barcode-counts/\",\n                            pattern = \"exp.*\\\\.csv\",\n                            full.names = TRUE)\nthresh_background &lt;- 4\n## ./data/pheno_data_metadata_2025-04-18.csv\npheno_data &lt;- readr::read_csv(paste0(\"./data/pheno_data_metadata_\",\n                                     today_date, \".csv\"))\n\n## filename &lt;- grep( \"exp200921\", barcode_files, value = TRUE)[2]\nbarcode_counts_aggregated &lt;- purrr::map(barcode_files, function(filename) {\n  barcode_counts &lt;- readr::read_csv(filename)\n  experience_name &lt;- filename |&gt; basename() |&gt; tools::file_path_sans_ext()\n  \n  ## 1) explicitly change replicates name to enable 1-1 mapping ----\n  if (experience_name==\"exp200921_dose response osim\") {\n    barcode_counts &lt;- barcode_counts |&gt; \n      dplyr::rename_with(\n        .fn = ~ gsub(\"exp200921_\", \"exp200921_dose_response_\", .x),\n        .cols = starts_with(\"Contro\"))\n  }\n  replicates_names &lt;- setdiff(colnames(barcode_counts), \"barcode_id\")\n  \n  ## 2) Remove lowly expressed barcodes ----\n  control_index &lt;- pheno_data |&gt; \n    dplyr::filter(Batch_ID==experience_name & \n                    Compound==\"Control\" &\n                    Replicates_ID %in% replicates_names) |&gt; \n    dplyr::pull(Replicates_ID)\n  signicant_barcodes_index &lt;- which(rowSums(barcode_counts[, control_index]) &gt; thresh_background)\n  filtered_barcode_counts &lt;- barcode_counts[signicant_barcodes_index,]\n  \n  message(paste(\"\\n\\nWe are considering experiment:\", experience_name, \"with\", nrow(filtered_barcode_counts), \"barcode IDs kept.\\n\\n\"))\n  \n  return(filtered_barcode_counts)\n}) |&gt; \n  purrr::reduce(~ inner_join(.x, .y, by = \"barcode_id\"))\n\n## Deal with specific duplicated colnames, resulting from control duplicates\n## barcode_counts_aggregated &lt;- barcode_counts_aggregated |&gt;\n##   dplyr::select(!ends_with(\".y\")) |&gt; \n##   dplyr::rename_with(.fn = ~ gsub(\"\\\\.x$\", \"\", .x),\n##                      .cols = dplyr::ends_with(\".x\"))\n\n## 3) keep only replicates present in pheno_data\nbarcode_counts_aggregated &lt;- barcode_counts_aggregated |&gt; \n  select(all_of(c(\"barcode_id\", pheno_data$Replicates_ID)))\n\n\n\n\n\nAfter filtering for background noise, and merging all experiences based on shared barcode IDs, 4629 unique barcode IDs are kept, for 532 samples, see Listing 2.1 for details.\nDensity plot of controls + justify why + check absence of outliers, to evaluate the relevance of this threshold, HTSFilter, comparison with existing filtering approaches.\n\n2.2.2 Normalisation\n\n\n\nNormalize barcodes so that the total number of counts per sample is equal to 100,000. This operation is performed in Listing 2.2.\n\n\n\n\nListing 2.2: Normalise by \\(100000\\).\n\n## 1) normalise by total number of counts ----\nbarcode_counts_normalised &lt;- barcode_counts_aggregated |&gt; \n  mutate(across(\n    .cols = where(is.numeric),                     \n    .fns = ~ (.x / sum(.x)) * 1e5))\n\n\n\n\n\nClose to two existing normalisation methods: Counts Per Million (CPM) which additionally scales raw counts by total library size and multiplies by \\(1,000,000\\) and Total Count Scaling (TCS): Scales raw counts by the total number of reads (or mapped reads) in each sample, then multiplies by a fixed number (e.g., 100,000). Would compare other normalisation approaches + ignore biological or technical biases + generate MA plots for verifying the mean-variance correction trend + not suitable for DEGs analyses. Apply concatenation phase of all samples before normalising. Preprocessing and normalisation functions for transcriptomics: a general overview\n\n2.2.3 Prepare SummarizedExperiment objects for normalised data\n\nHigher level of granularity in Listing 2.3:\n\n\n\n\nListing 2.3: Simply compute the Pearson correlation score at the replicate level, and save the output as a SummarizedExperiment.\n\n## 2) prepare SummarizedExperiment inputs ----\n## Barcode counts at replicate level\nbarcode_normalised_replicates_mat &lt;- barcode_counts_normalised |&gt; \n                  tibble::column_to_rownames(\"barcode_id\") |&gt; \n                  as.matrix()\n\n## Sample metadata\npheno_data_replicates &lt;- pheno_data |&gt; \n  tibble::column_to_rownames(\"Replicates_ID\") \n\n## Feature metadata\nbarcode_metadata &lt;- tibble::tibble(barcode_id = barcode_counts_normalised$barcode_id)\nrow.names(barcode_metadata) &lt;- barcode_metadata$barcode_id\n\n## 3) Buid and Save SummarizedExperiment\nse_replicates &lt;- SummarizedExperiment::SummarizedExperiment(\n  assays = list(counts = barcode_normalised_replicates_mat),\n  rowData = barcode_metadata,\n  colData = pheno_data_replicates)\n\n\n\n\n\nMedium level of granularity in Listing 2.4, averaging over replicates:\n\n\n\n\nListing 2.4: Simply compute the Pearson correlation score at the Compound per Batch level.\n\nbarcode_counts_long &lt;- barcode_counts_normalised |&gt; \n  tidyr::pivot_longer(-barcode_id, \n                      names_to = \"Replicates_ID\",\n                      values_to = \"Barcode_Counts\") |&gt; \n  dplyr::inner_join(pheno_data, by=\"Replicates_ID\")\n\nbarcode_counts_wider_compound_batch &lt;- barcode_counts_long |&gt; \n  tidyr::pivot_wider(id_cols = c(barcode_id), \n                     names_from = c(Batch_ID, Compound, Concentrations_ID, Duration_ID),\n                     names_sep = \":\",\n                     values_from = Barcode_Counts, \n                     values_fn=mean)\n\npheno_compound_batch &lt;- tibble::tibble(original =setdiff(colnames(barcode_counts_wider_compound_batch),\"barcode_id\")) |&gt;\n  mutate(Batch_ID = stringr::str_split_i(original, \":\", 1),\n         Compound = stringr::str_split_i(original, \":\", 2), \n         Concentrations_ID = stringr::str_split_i(original, \":\", 3), \n         Duration_ID = stringr::str_split_i(original, \":\", 4)) |&gt;\n  inner_join(pheno_data |&gt; select(Batch_ID, Pathway, MoA, Compound, \n                                  Concentrations, Concentrations_ID, Duration, Duration_ID), \n             by = c(\"Batch_ID\", \"Compound\", \"Concentrations_ID\", \"Duration_ID\")) |&gt; \n  dplyr::distinct() |&gt; \n  dplyr::select(-Concentrations_ID, -Duration_ID) |&gt; \n  tibble::column_to_rownames(\"original\") \n\nse_compound_batch &lt;- SummarizedExperiment::SummarizedExperiment(\n  assays = list(counts = barcode_counts_wider_compound_batch |&gt; \n                  tibble::column_to_rownames(\"barcode_id\") |&gt; \n                  as.matrix()),\n  rowData = barcode_metadata,\n  colData = pheno_compound_batch)\n\n\n\n\n\nLow level of granularity in Listing 2.5, with one CC per compound:\n\n\n\n\nListing 2.5: Compute the Pearson correlation score, after averaging the barcode counts per compound.\n\nbarcode_counts_wider_by_compound &lt;- barcode_counts_long |&gt; \n  tidyr::pivot_wider(id_cols = c(barcode_id), \n                     names_from = c(Compound),\n                     values_from = Barcode_Counts, \n                     values_fn=mean)\n\npheno_compound &lt;- tibble::tibble(Compound = setdiff(colnames(barcode_counts_wider_by_compound), \"barcode_id\")) |&gt;\n  inner_join(pheno_data |&gt; select(Pathway, MoA, Compound), \n             by = c(\"Compound\")) |&gt; \n  dplyr::distinct() |&gt; \n  tibble::column_to_rownames(\"Compound\") \n\nse_compound &lt;- SummarizedExperiment::SummarizedExperiment(\n  assays = list(counts = barcode_counts_wider_by_compound |&gt; \n                  tibble::column_to_rownames(\"barcode_id\") |&gt; \n                  as.matrix()),\n  rowData = barcode_metadata,\n  colData = pheno_compound)\n\n\n\n\n\nCodesaveRDS(se_replicates, file = paste0(\"./results/compounds/se_normalised_per_replicate_\",\n                          today_date, \".rds\"))\nsaveRDS(se_compound_batch, file = paste0(\"./results/compounds/se_normalised_per_compound_by_batch_\",\n                          today_date, \".rds\"))\nsaveRDS(se_compound, file = paste0(\"./results/compounds/se_normalised_per_compound_\",\n                          today_date, \".rds\"))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Methods: normalise, identify DRBs and save as `SummarizedExperiment` objects</span>"
    ]
  },
  {
    "objectID": "methods.html#differential-analyses-and-binarisation",
    "href": "methods.html#differential-analyses-and-binarisation",
    "title": "\n2  Methods: normalise, identify DRBs and save as SummarizedExperiment objects\n",
    "section": "\n2.3 Differential analyses and Binarisation",
    "text": "2.3 Differential analyses and Binarisation\n\nCalculate mean of the 4 controls, followed by Differential Represented Barcode Analysis: binarise each replicate, assigning a 1 if Fold change is above 3 with respect to Mean value, and 0 otherwise\n\n\n\n\nListing 2.6: Compute the averaged value for control replicates, then binarise for each compound. A 1 denoting a significant positive enrichment for a given barcode_id.\n\n## Step 1: Compute control means per barcode_id and Batch ----\nthreshold_FC &lt;- 3\ncontrol_means &lt;- barcode_counts_long |&gt;\n  filter(Compound == \"Control\") |&gt;\n  group_by(Batch_ID, barcode_id) |&gt;\n  summarise(Control_Mean = mean(Barcode_Counts), .groups = \"drop\")\n\n## Step 2: Join control mean to full dataset ----\nbarcode_discretised_replicates &lt;- barcode_counts_long |&gt;\n  left_join(control_means, \n            by = c(\"Batch_ID\",\"barcode_id\"))\n\n## Step 3: Compute Fold Change and discretise ----\nbarcode_discretised_replicates &lt;- barcode_discretised_replicates |&gt;\n  filter(Compound != \"Control\") |&gt;\n  mutate(Diff = Barcode_Counts - Control_Mean,\n    Barcode_Counts = if_else(Diff &gt; threshold_FC, 1, 0)) |&gt;\n  ## Final cleanup \n  select(-Diff, -Control_Mean)  |&gt; \n  dplyr::mutate(Barcode_Counts = as.logical(Barcode_Counts))\n\n\n\n\nBatch effect correction for integrating across batches? // As Vera emphasised it out, why keeping only positive values? Negative are also interesting. Why not pairing \\(p\\)-values and fold-change (considering indeed really small sample sizes)? // All these operations can be performed with one run, using lm, and a model as such, \\(\\text{Expr} \\sim 0 + \\text{Gene} + \\text{Batch} + \\text{Drug}\\), with a contr.treatment design matrix // Perform sensitivity analyses to evaluate the impact of threshold criteriaon for binarisation on downstream analyses. 1.\n\n2.3.1 SummarizedExperiment of binarised markers\n\n\nSummarizedExperiment at the replicates level (controls being discarded)\n\n\nCode## Step 4: Save as a SummarizedExperiment ----\nbarcode_discretised_replicates_mat &lt;- barcode_discretised_replicates |&gt; \n  tidyr::pivot_wider(id_cols = barcode_id, names_from = Replicates_ID, values_from = Barcode_Counts)\n\npheno_replicates_discretised &lt;- pheno_data |&gt; \n  dplyr::filter(Replicates_ID %in% barcode_discretised_replicates$Replicates_ID) |&gt; \n  tibble::column_to_rownames(\"Replicates_ID\") \n\nse_discretised_replicates &lt;- SummarizedExperiment::SummarizedExperiment(\n  assays = list(binarised = barcode_discretised_replicates_mat |&gt; \n                  tibble::column_to_rownames(\"barcode_id\") |&gt; \n                  as.matrix()),\n  rowData = barcode_metadata,\n  colData = pheno_replicates_discretised)\n\nsaveRDS(se_discretised_replicates,\n        file = paste0(\"./results/compounds/se_discretised_per_replicate_\",\n                      today_date, \".rds\"))\n\n\n\nLogical AND over replicates: drug by batch (and concentration and time).\n\n\n\n\nListing 2.7: Average the replicates, using a all operator.\n\n## 2) discretised correlation at the compound by batch level (averaging over replicates), with an all function\nbarcode_discretised_compound_batch &lt;- barcode_discretised_replicates |&gt; \n   tidyr::pivot_wider(id_cols = c(barcode_id), \n                     names_from = c(Batch_ID, Compound, Concentrations_ID, Duration_ID),\n                     names_sep = \":\",\n                     values_from = Barcode_Counts, \n                     values_fn=all)\n\npheno_discretised_compound_batch &lt;- pheno_compound_batch[setdiff(colnames(barcode_discretised_compound_batch), \"barcode_id\"), ]\n\nse_compound_batch_discretised &lt;- SummarizedExperiment::SummarizedExperiment(\n  assays = list(discretised = barcode_discretised_compound_batch |&gt; \n                  tibble::column_to_rownames(\"barcode_id\") |&gt; \n                  as.matrix()),\n  rowData = barcode_metadata,\n  colData = pheno_discretised_compound_batch)\n\nsaveRDS(se_compound_batch_discretised,\n        file = paste0(\"./results/compounds/se_discretised_per_compound_by_batch_\",\n                      today_date, \".rds\"))\n\n\n\n\n\nAverage over compounds.\n\n\n\n\nListing 2.8: Aggregate at the compound level, assigning a 1 if barcode cell lines were found positiveliy enriched in all compounds.\n\n## 2) discretised correlation at the compound by batch level (averaging over replicates), with an all function\nbarcode_discretised_compound &lt;- barcode_discretised_replicates |&gt; \n   tidyr::pivot_wider(id_cols = c(barcode_id), \n                     names_from = c(Compound),\n                     names_sep = \":\",\n                     values_from = Barcode_Counts, \n                     values_fn=all)\n\npheno_discretised_compound&lt;- pheno_compound[setdiff(colnames(barcode_discretised_compound), \"barcode_id\"), ]\n\nse_compound_discretised &lt;- SummarizedExperiment::SummarizedExperiment(\n  assays = list(discretised = barcode_discretised_compound |&gt; \n                  tibble::column_to_rownames(\"barcode_id\") |&gt; \n                  as.matrix()),\n  rowData = barcode_metadata,\n  colData = pheno_discretised_compound)\n\nsaveRDS(se_compound_discretised,\n        file = paste0(\"./results/compounds/se_discretised_per_compound_\",\n                      today_date, \".rds\"))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Methods: normalise, identify DRBs and save as `SummarizedExperiment` objects</span>"
    ]
  },
  {
    "objectID": "methods.html#footnotes",
    "href": "methods.html#footnotes",
    "title": "\n2  Methods: normalise, identify DRBs and save as SummarizedExperiment objects\n",
    "section": "",
    "text": "Test the Helmert contrast to evaluate compound dose response, or time-course replicates. Also For repeated measures across time, see One Way repeated measure ANOVA in R↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Methods: normalise, identify DRBs and save as `SummarizedExperiment` objects</span>"
    ]
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "\n3  Results: Heatmaps and Drug networks, based on barcode fingerprints\n",
    "section": "",
    "text": "3.1 Reproducibility\nI list below the R packages required to reproduce the analyses.\nCode## data wrangling\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(purrr)\n\n## reporting\nlibrary(flextable)\n\n## plotting\nlibrary(ggplot2)\nlibrary(ComplexHeatmap)\nlibrary(cowplot)\nlibrary(grid)\nlibrary(RColorBrewer)\nlibrary(igraph)\n\n## auxiliary functions\nsource(\"R/utils.R\")\ntoday_date &lt;- \"2025-04-28\"\n## today_date &lt;- format(Sys.Date(), \"%Y-%m-%d\")\n\n## set the seed, for fixing generation of ComplexHeatmaps (dendogram clustering)\nset.seed(20)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results: Heatmaps and Drug networks, based on barcode fingerprints</span>"
    ]
  },
  {
    "objectID": "results.html#compute-compound-similarities",
    "href": "results.html#compute-compound-similarities",
    "title": "\n3  Results: Heatmaps and Drug networks, based on barcode fingerprints\n",
    "section": "\n3.2 Compute Compound Similarities",
    "text": "3.2 Compute Compound Similarities\n\nActual computation of the correlation matrix using stats::cor.\nYet, we have to try other correlation methods on the continuous space, or consider other metrics if working on the discrete space. Unbalanced Wassertein distance, or relatives, for distinct input and output dimensions.\n\n\n3.2.1 Compound Heatmaps\n\n\nSome tutorials:\n\nBlend of useful resources on generating Heatmaps:\nMapping quantitative data to color, from Gehlenborg and Wong (2012):\n\nReal-Life Examples with ComplexHeatmap:\n\nHeatmap with transcriptomic expression\nHeatmap with genomic expression\nGenome-level Heatmap\n\nPlotting large heatmaps in R and Rasterisation, with thousands of genes to be considered.\nControl size of Heatmaps\n\n\nReal-life examples with ggplot2\nReal-Life examples with funkyheatmap CRAN package\n\n\n\n\n3.2.1.1 Heatmap with Pearson correlation score\n\nHeatmap in ?fig-heatmap-normalised-replicate is generated at the replicate level:\n\n\nCode## Read SummarizedExperiment object\nse_normalised_replicate &lt;- readRDS(paste0(\"./results/compounds/se_normalised_per_replicate_\", today_date, \".rds\"))\nse_normalised_replicate_mat &lt;- SummarizedExperiment::assay(se_normalised_replicate)\nse_normalised_pheno_data_replicate &lt;- SummarizedExperiment::colData(se_normalised_replicate)\nse_normalised_pheno_data_replicate$log10Conc &lt;- if_else(se_normalised_pheno_data_replicate$Concentrations==0, \n                                   0, \n                                   -log10(se_normalised_pheno_data_replicate$Concentrations))\n## Compute global correlation score\ncor_per_replicate &lt;- cor(se_normalised_replicate_mat)\n\n## Define clustering colours\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_per_replicate), 0, 1),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## Define custom colour Heatmap annotation\n## num_batches &lt;- length(unique(se_normalised_pheno_data_replicate$Batch_ID))\n## num_compounds &lt;- length(unique(se_normalised_pheno_data_replicate$Compound))\n## num_moa &lt;- length(unique(se_normalised_pheno_data_replicate$MoA))\n## \n## batch_col &lt;- setNames(colorRampPalette(brewer.pal(8, \"Dark2\"))(num_batches), \n##                       unique(se_normalised_pheno_data_replicate$Batch_ID))\n## compound_col &lt;- setNames(colorRampPalette(brewer.pal(11, \"Spectral\"))(num_compounds), \n##                          unique(se_normalised_pheno_data_replicate$Compound))\n## moa_col &lt;- setNames(colorRampPalette(brewer.pal(12, \"Set3\"))(num_moa), \n##                     unique(se_normalised_pheno_data_replicate$MoA))\n\n\n## Heatmap annotation\ntop_ha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_normalised_pheno_data_replicate |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Batch_ID, MoA, Compound)) \n                                        ## col = list(Batch_ID = batch_col, \n                                        ##            MoA = moa_col, \n                                        ##            Compound = compound_col))\n\nrow_ha &lt;- ComplexHeatmap::rowAnnotation(Concentration =\n                                          ComplexHeatmap::anno_barplot(se_normalised_pheno_data_replicate$log10Conc), \n                                        Duration = paste0(se_normalised_pheno_data_replicate$Duration, \"d\"))\n\n## Generate Heatmap\nheatmap_normalised_replicates &lt;- ComplexHeatmap::Heatmap(cor_per_replicate, \n                                          col=col_heatmap_scale, \n                                          name = \"CC for all Replicates\", \n                                          show_row_names = TRUE,\n                                          show_column_names = FALSE, \n                                          row_dend_reorder = TRUE,\n                                          column_dend_reorder = TRUE, \n                                          row_names_gp = gpar(fontsize = 2), \n                                          top_annotation = top_ha, \n                                          right_annotation = row_ha) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/compounds/heatmap_normalised_replicates_\", today_date,\".pdf\"), \n       heatmap_normalised_replicates, dpi = 600, width = 20, height = 20)\n\n\n\nHeatmap in ?fig-heatmap-normalised-compound-batch is generated by averaging normalised barcode counts over replicates:\n\n\nCode## Read SummarizedExperiment object\nse_normalised_compound_batch &lt;- readRDS(paste0(\"./results/compounds/se_normalised_per_compound_by_batch_\", today_date, \".rds\"))\nse_normalised_compound_batch_mat &lt;- SummarizedExperiment::assay(se_normalised_compound_batch)\nse_pheno_data_normalised_compound_batch &lt;- SummarizedExperiment::colData(se_normalised_compound_batch)\n## Compute global correlation score\ncor_per_compound_by_batch &lt;- cor(se_normalised_compound_batch_mat)\n\n## Define clustering colours\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_per_compound_by_batch), 0, 1),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## Heatmap annotation\nha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_pheno_data_normalised_compound_batch |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Pathway))\n\n## Define Heatmap\nheatmap_normalised_compound_batch &lt;- ComplexHeatmap::Heatmap(cor_per_compound_by_batch, \n                                          col=col_heatmap_scale, \n                                          name = \"CC for all Compound\", \n                                          show_row_names = TRUE,\n                                          show_column_names = TRUE, \n                                          row_dend_reorder = TRUE,\n                                          column_dend_reorder = TRUE, \n                                          column_names_gp = gpar(fontsize = 8),\n                                          row_names_gp = gpar(fontsize = 8), \n                                          top_annotation = ha) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/compounds/heatmap_normalised_compound_by_batch_\", today_date,\".pdf\"), \n       heatmap_normalised_compound_batch, dpi = 600, width = 20, height = 20)\n\n\n\nHeatmap in ?fig-heatmap-global-compound is generated at the compound level:\n\n\nCode## Read SummarizedExperiment object\nse_normalised_compound &lt;- readRDS(paste0(\"./results/compounds/se_normalised_per_compound_\", today_date, \".rds\"))\nse_normalised_compound_mat &lt;- SummarizedExperiment::assay(se_normalised_compound)\nse_normalised_pheno_data_compound &lt;- SummarizedExperiment::colData(se_normalised_compound)\n## Compute global correlation score\ncor_per_compound &lt;- cor(se_normalised_compound_mat)\n\n## Define clustering colours\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_per_compound), 0, 1),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## Heatmap annotation\nha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_normalised_pheno_data_compound |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Pathway))\n\n## Define Heatmap\nheatmap_normalised_compound &lt;- ComplexHeatmap::Heatmap(cor_per_compound, \n                                          col=col_heatmap_scale, \n                                          name = \"CC for all Compound\", \n                                          show_row_names = TRUE,\n                                          show_column_names = TRUE, \n                                          row_dend_reorder = FALSE,\n                                          column_dend_reorder = TRUE, \n                                          ## font size\n                                          row_names_gp = gpar(fontsize = 8), \n                                          top_annotation = ha) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/compounds/heatmap_normalised_compound_\", today_date,\".pdf\"), \n       heatmap_normalised_compound, dpi = 600, width = 20, height = 20)\n\n\n\n3.2.1.2 Heatmap with Pearson correlation and binarised values\n\nHeatmap at the replicates level in ?fig-heatmap-binarised-replicates:\n\n\nCode## Read SummarizedExperiment object\nse_binarised_replicates &lt;- readRDS(paste0(\"./results/compounds/se_discretised_per_replicate_\", today_date, \".rds\"))\nse_binarised_replicates_mat &lt;- SummarizedExperiment::assay(se_binarised_replicates)\nse_binarised_pheno_data_replicate &lt;- SummarizedExperiment::colData(se_binarised_replicates)\n## Compute global correlation score\ncor_per_replicates &lt;- cor(se_binarised_replicates_mat)\n\n## Define clustering colours\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_per_replicates), 0, 1),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## Heatmap annotation\nha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_binarised_pheno_data_replicate |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Pathway, Batch_ID, Compound))\n\n\nheatmap_binarised_replicates &lt;- ComplexHeatmap::Heatmap(cor_per_replicates, \n                                            col=col_heatmap_scale, \n                                            name = \"CC at binarised Compound Level\",\n                                            show_row_names = TRUE,\n                                            show_column_names = TRUE, \n                                            row_dend_reorder = FALSE,\n                                            column_dend_reorder = TRUE, \n                                            ## font size\n                                            row_names_gp = gpar(fontsize = 3), \n                                            top_annotation = ha) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/compounds/heatmap_binarised_replicates_\", today_date,\".pdf\"), \n       heatmap_binarised_replicates, dpi = 600, width = 20, height = 20)                                            \n\n\n\nHeatmap at the compound by batch level in ?fig-heatmap-binarised-compound-by-batch (aggregated over technical replicates):\n\n\nCode## Read SummarizedExperiment object\nse_binarised_compound_batch &lt;- readRDS(paste0(\"./results/compounds/se_discretised_per_compound_by_batch_\", today_date, \".rds\"))\nse_binarised_compound_batch_mat &lt;- SummarizedExperiment::assay(se_binarised_compound_batch)\nse_binarised_pheno_data_compound_batch &lt;- SummarizedExperiment::colData(se_binarised_compound_batch)\n## Compute global correlation score\ncor_per_compound_by_batch &lt;- cor(se_binarised_compound_batch_mat)\n\n## Define clustering colours\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_per_compound_by_batch), 0, 1),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## Heatmap annotation\nha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_binarised_pheno_data_compound_batch |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Pathway, MoA))\n\n\nheatmap_binarised_compound_batch &lt;- ComplexHeatmap::Heatmap(cor_per_compound_by_batch, \n                                            col=col_heatmap_scale, \n                                            name = \"CC at binarised Compound Level\",\n                                            show_row_names = TRUE,\n                                            show_column_names = TRUE, \n                                            row_dend_reorder = FALSE,\n                                            column_dend_reorder = TRUE, \n                                            ## font size\n                                            row_names_gp = gpar(fontsize = 8), \n                                            top_annotation = ha) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/compounds/heatmap_binarised_compound_by_batch_\", today_date,\".pdf\"), \n       heatmap_binarised_compound_batch, dpi = 600, width = 20, height = 20)                                            \n\n\n\nHeatmap at the compound level in ?fig-heatmap-binarised-compound.\n\n\nCode## Read SummarizedExperiment object\nse_binarised_compound &lt;- readRDS(paste0(\"./results/compounds/se_discretised_per_compound_\", today_date, \".rds\"))\nse_binarised_compound_mat &lt;- SummarizedExperiment::assay(se_binarised_compound)\nse_binarised_pheno_data_compound &lt;- SummarizedExperiment::colData(se_binarised_compound)\n## Compute global correlation score\ncor_per_compound &lt;- cor(se_binarised_compound_mat)\n\n## Define clustering colours\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_per_compound), 0, 1),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## Heatmap annotation\nha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_binarised_pheno_data_compound |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Pathway, MoA))\n\n\nheatmap_binarised_compound &lt;- ComplexHeatmap::Heatmap(cor_per_compound, \n                                            col=col_heatmap_scale, \n                                            name = \"CC at binarised Compound Level\",\n                                            show_row_names = TRUE,\n                                            show_column_names = TRUE, \n                                            column_names_gp = gpar(fontsize = 8),\n                                            row_dend_reorder = TRUE,\n                                            column_dend_reorder = TRUE, \n                                            row_names_gp = gpar(fontsize = 8), \n                                            top_annotation = ha) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/compounds/heatmap_binarised_compound_\", today_date,\".pdf\"), \n       heatmap_binarised_compound, dpi = 600, width = 20, height = 20)                                            \n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Compound Networks\n\nPlot weighted undirected compound graphs with igraph::graph_from_adjacency_matrix in ?fig-igraph-drug, filtering out pairwise connections between 2 drugs if the \\(p\\)-value is not significant and absolute correlation score is below 0.8:\n\n\nCode## 1) Compute correlation matrix and p-values ----\ncor_res &lt;- Hmisc::rcorr(se_binarised_compound_mat, type = \"pearson\")\ncor_binarised_compound &lt;- cor_res$r\npval_binarised_compound &lt;- cor_res$P\n\nadj_mat &lt;- cor_binarised_compound\nadj_mat[pval_binarised_compound &gt; 0.05/ncol(cor_res)] &lt;- 0\n\n## 2) build igraph adjacency matrix ----\ncompound_graph &lt;- igraph::graph_from_adjacency_matrix(adjmatrix=adj_mat, \n                                          weighted = TRUE,\n                                          diag = FALSE, \n                                          mode = \"undirected\")\n## 3) igraph customisation ----\ncompound_graph$date &lt;- today_date\nE(compound_graph)$color &lt;- if_else(E(compound_graph)$weight &gt;0, \"red\", \"blue\")\nE(compound_graph)$weight &lt;- abs(E(compound_graph)$weight)\n\nlayout_graph &lt;- igraph::layout_with_fr(compound_graph,\n                                       niter = 500)\n\nvertex_structure &lt;- se_binarised_pheno_data_compound |&gt; \n  as.data.frame() |&gt; \n  dplyr::mutate(color = if_else(Pathway==\"EGFR\", \"green\", \"yellow\"))\n\nigraph::V(compound_graph)$color &lt;- vertex_structure$color\n\npdf(paste0(\"figures/compounds/compound_graph_\", today_date, \".pdf\"), \n    width = 16, height = 16, useDingbats = TRUE, compress = FALSE)\nplot(compound_graph, layout = layout_graph, vertex.size = 10,\n     ## vertex.label.dist= 2,\n     main = \"Compound network interaction.\n     In green, drugs related with the EGFR mechanism,\n     and in yellow other pathways.\n     Edge widths are proportional to the coefficient of correlation.\", \n     edge.width = igraph::E(compound_graph)$weight * 20,\n     vertex.label.cex = 1, curved = 0.2)\ndev.off()\n##  png \n##    2\n\n## 4) export PNG and readable graph formats for Neo4J\nigraph::write_graph(graph = compound_graph, \n                    file = paste0(\"./results/compounds/compound_network_\", today_date, \".graphml\"),\n                    format = \"graphml\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results: Heatmaps and Drug networks, based on barcode fingerprints</span>"
    ]
  },
  {
    "objectID": "results.html#compute-cell-lines-similarities",
    "href": "results.html#compute-cell-lines-similarities",
    "title": "\n3  Results: Heatmaps and Drug networks, based on barcode fingerprints\n",
    "section": "\n3.3 Compute Cell Lines Similarities",
    "text": "3.3 Compute Cell Lines Similarities\n\n3.3.1 Cell Line by Compound\n\nCodese_binarised_compound_batch_fac &lt;- apply(se_binarised_compound_batch_mat, 2, as.character)\n\n## Heatmap annotation\nha &lt;- ComplexHeatmap::HeatmapAnnotation(df = se_binarised_pheno_data_compound_batch |&gt; \n                                          as.data.frame() |&gt; \n                                          dplyr::select(Batch_ID, Pathway, Compound))\n\nheatmap_cell_lines_by_sample &lt;- ComplexHeatmap::Heatmap(se_binarised_compound_batch_fac, \n                                                        col = c(\"TRUE\" = \"red\", \"FALSE\" = \"blue\"), \n                                                        name = \"Heatmap: cell-line by sample\",\n                                                        show_row_names = FALSE,\n                                                        row_dend_reorder = TRUE,\n                                                        ## clustering_distance_rows = \"pearson\",\n                                                        show_row_dend = FALSE,\n                                                        column_dend_reorder = TRUE, \n                                                        show_column_names = TRUE, \n                                                        ## clustering_distance_columns = \"pearson\",\n                                                        column_names_gp = gpar(fontsize = 4), \n                                                        top_annotation = ha, \n                                                        ## compression issues\n                                                        use_raster = TRUE) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/cell_lines/heatmap_cell_lines_by_samples_\", today_date,\".pdf\"), \n       heatmap_cell_lines_by_sample, dpi = 300, width = 20, height = 20)                                            \n\n\n\n3.3.2 Cell Line Correlation\n\nCode## 1) evaluation of cell resistance\npresent_cells &lt;- rowSums(se_binarised_compound_batch_mat)\nhist(present_cells, \n     breaks = length(unique(present_cells)),\n     main=NULL)\n\n## 2) filtered Heatmaps \nthreshold_cell_prevalence &lt;- 10 ## alternatively, remove cells that are not present in all samples\nse_binarised_compact &lt;- se_binarised_compound_batch_mat[present_cells &gt;\n                                                             threshold_cell_prevalence, ]\ncor_cell_lines &lt;- cor(t(se_binarised_compact))\ncol_heatmap_scale &lt;- circlize::colorRamp2(c(min(cor_cell_lines, na.rm = TRUE),\n                                            0, \n                                            max(cor_cell_lines, na.rm = TRUE)),\n                                      c(\"blue\", \"white\", \"red\"))\n\n## 3) generate Heatmap of correlation cell lines\nheatmap_cell_lines_by_cell_lines &lt;- ComplexHeatmap::Heatmap(cor_cell_lines, \n                                                        col = col_heatmap_scale, \n                                                        name = \"Heatmap: cell-line by cell line\",\n                                                        show_row_names = FALSE,\n                                                        row_dend_reorder = TRUE,\n                                                        show_row_dend = TRUE,\n                                                        column_dend_reorder = TRUE, \n                                                        show_column_names = FALSE, \n                                                        na_col = \"black\", \n                                                        use_raster = TRUE, \n                                                        raster_resize_mat = mean) |&gt; \n  ComplexHeatmap::draw() |&gt; \n  grid::grid.grabExpr()\n\nggsave(paste0(\"figures/cell_lines/heatmap_cell_lines_by_cell_lines_\", today_date,\".pdf\"), \n       heatmap_cell_lines_by_cell_lines, dpi = 600, width = 20, height = 20)    \n\n\n\n\n\n\nFigure 3.1: Histogram of the distribution of cell resistance (for a given barcode ID, returns the total number of cell lines identified).\n\n\n\n\n\n\n\n\nGehlenborg, Nils, and Bang Wong. 2012. ‘Mapping Quantitative Data to Color’. Nature Methods 9 (8): 769–69. https://doi.org/10.1038/nmeth.2134.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results: Heatmaps and Drug networks, based on barcode fingerprints</span>"
    ]
  },
  {
    "objectID": "perspectives.html",
    "href": "perspectives.html",
    "title": "4  Future perspectives: single-cell integration.",
    "section": "",
    "text": "4.0.1 Alternative metrics\n\nCompute correlations with strongly sparse vectors?\n\n\n\n4.0.2 Pair Single Cell with (or without) Drug fingerprints\n\nSingle cell and compound response largest database\nBiologist perspective\n\nSingle-cell lineage capture across genomic modalities with CellTag-multi reveals fate-specific gene regulatory changes -&gt; use of single-cell lineage-tracing (scLT).\nHigh-resolution, noninvasive single-cell lineage tracing in mice and humans based on DNA methylation epi-mutations.\n\nMing Tommy Tang lists in Single-cell LinkedIn post trendy papers and tools for multi-sample, single-cell RNAseq differential expression analysis.\n\n\n4.0.2.1 Correct for Batch Effects\n\nDESeq2-MultiBatch: Batch Correction for Multi-Factorial RNA-seq Experiments, avalaible as open-source GH repository, from Roy, Monthony, and Torkamaneh (2025).\n\n\n\n4.0.2.2 Drug-response\n\nTRADE: Transcriptome-wide analysis of differential expression in perturbation atlases, from Nadig et al. (2025). The paper notably reports how to model a compound-dose response curve with a Hill equation. Avalaible as an open-source GH repository TRADEtools. R TRADE Tutorial\n\n\n\n\n4.0.3 Barcode Differential Analysis\n\n4.0.3.1 bartools and BARtab\n\nAnalysis of synthetic cellular barcodes in the genome and transcriptome with BARtab and bartools.\n\n\n\n4.0.3.2 DEBRA\n\nPros DEBRA\n\nBetter characterisation of the mean-variance deviation -&gt; between trended or shrinkage, trended is favoured.\n\nCons DEBRA:\n\nDEBRA does not account for outliers expression, nor zero-inflated counts -&gt; recommendation of glmQLFit and glmQLFTest for routine GLM-based DE analyses, from EdgeR: Explaning dispersion types to newbies.\nComplex protocol for discarding lowly differentially expressed barcodes.\nNo available BioConductor/CRAN Repository, while latest DEBRA GitHub update dates back more than 4 years.\n\n\n\n\n4.0.3.3 Combine Fold change and \\(p\\)-value\n\nCombine statistical discernibility (aka significance) with practical significance\n\n\n\n\n4.0.4 Drug clustering and mapping\n\nUse of graph clustering approaches? Like Louvain? + multiple case studies, how to combine them (2 vials of cell lines)?\nCompare with ATC prediction and clustering: PDATC-NCPMKL-updated GH Repo.\n\n\n\n\n\nNadig, Ajay, Joseph M. Replogle, Angela N. Pogson, Mukundh Murthy, Steven A. McCarroll, Jonathan S. Weissman, Elise B. Robinson, and Luke J. O’Connor. 2025. ‘Transcriptome-Wide Analysis of Differential Expression in Perturbation Atlases’. Nature Genetics, April, 1–10. https://doi.org/10.1038/s41588-025-02169-3.\n\n\nRoy, Julien, Adrian S. Monthony, and Davoud Torkamaneh. 2025. ‘DESeq2-MultiBatch: Batch Correction for Multi-Factorial RNA-seq Experiments’. 22 April 2025. https://doi.org/10.1101/2025.04.20.649392.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Future perspectives: single-cell integration.</span>"
    ]
  },
  {
    "objectID": "cell-lines-databases.html",
    "href": "cell-lines-databases.html",
    "title": "Appendix A — Appendix: publish to standardised cell line repositories.",
    "section": "",
    "text": "A.1 Repository organisation and Data tracking",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: publish to standardised cell line repositories.</span>"
    ]
  },
  {
    "objectID": "cell-lines-databases.html#repository-organisation-and-data-tracking",
    "href": "cell-lines-databases.html#repository-organisation-and-data-tracking",
    "title": "Appendix A — Appendix: publish to standardised cell line repositories.",
    "section": "",
    "text": "Project Code Organisation\nData Fingerprinting with MDA5 and Environment Snapshots: R and Code tracking\nLarge datasets versioning:\n\nDataLad VS DVC\nDataLad Versus DVC, and DataLad Versus DVC V2\nGit LFS VS Alembic\n\nHomogenise Excel colnames, and other spreadsheet tips",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: publish to standardised cell line repositories.</span>"
    ]
  },
  {
    "objectID": "cell-lines-databases.html#publish-cell-lines-on-web-repositories",
    "href": "cell-lines-databases.html#publish-cell-lines-on-web-repositories",
    "title": "Appendix A — Appendix: publish to standardised cell line repositories.",
    "section": "A.2 Publish cell lines on Web repositories",
    "text": "A.2 Publish cell lines on Web repositories\n\ncellosaurus General Comments and cellosaurus Official Website, from(Bairoch 2018; Robin, Capes-Davis, and Bairoch 2020). Specifically, the CLASTR algorithm relies on short-tandem repeat patterns to map user-provided cell lines with the ones available in Cellosaurus database.\nBgee.\n\n\n\n\n\n\n\nBairoch, Amos. 2018. ‘The Cellosaurus, a Cell-Line Knowledge Resource’. Journal of Biomolecular Techniques : JBT 29 (2): 25–38. https://doi.org/10.7171/jbt.18-2902-002.\n\n\nRobin, Thibault, Amanda Capes-Davis, and Amos Bairoch. 2020. ‘CLASTR: The Cellosaurus STR Similarity Search Tool - A Precious Help for Cell Line Authentication’. International Journal of Cancer 146 (5): 1299–1306. https://doi.org/10.1002/ijc.32639.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: publish to standardised cell line repositories.</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliographic References",
    "section": "",
    "text": "Bairoch, Amos. 2018. “The Cellosaurus, a\nCell-Line Knowledge Resource.” Journal of\nBiomolecular Techniques : JBT 29 (2): 25–38. https://doi.org/10.7171/jbt.18-2902-002.\n\n\nGehlenborg, Nils, and Bang Wong. 2012. “Mapping Quantitative Data\nto Color.” Nature Methods 9 (8): 769–69. https://doi.org/10.1038/nmeth.2134.\n\n\nNadig, Ajay, Joseph M. Replogle, Angela N. Pogson, Mukundh Murthy,\nSteven A. McCarroll, Jonathan S. Weissman, Elise B. Robinson, and Luke\nJ. O’Connor. 2025. “Transcriptome-Wide Analysis of Differential\nExpression in Perturbation Atlases.” Nature Genetics,\nApril, 1–10. https://doi.org/10.1038/s41588-025-02169-3.\n\n\nRobin, Thibault, Amanda Capes-Davis, and Amos Bairoch. 2020.\n“CLASTR: The Cellosaurus STR Similarity\nSearch Tool - A Precious Help for Cell Line\nAuthentication.” International Journal of Cancer 146\n(5): 1299–1306. https://doi.org/10.1002/ijc.32639.\n\n\nRoy, Julien, Adrian S. Monthony, and Davoud Torkamaneh. 2025.\n“DESeq2-MultiBatch: Batch Correction for\nMulti-Factorial RNA-seq Experiments.”\nApril 22, 2025. https://doi.org/10.1101/2025.04.20.649392.",
    "crumbs": [
      "Appendices",
      "Bibliographic References"
    ]
  }
]